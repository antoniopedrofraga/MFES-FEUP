class ConfigSearcher
types
		public string = Utilities`string;
		public config = Utilities`config;
instance variables
		private root : Feature;
		private nodeCount : int;
		private restrictedInvalidSubsets : seq of config;
		public validConfigs : seq of config := [];
operations
  	public ConfigSearcher: Feature ==> ConfigSearcher
  						ConfigSearcher(r) == (root := r; nodeCount := root.nodeCount(); restrictedInvalidSubsets := root.invalidSubsets(); return self;);
  	public searchConfigs: () ==> () 
  					searchConfigs() == (
  						searchFeatureTree(root, false);
  						applyRestrictions();
  					);
  	public applyRestrictions: () ==> ()
  					applyRestrictions() ==
  					(
  							-- dcl newValidConfigs : set of config := {elem | elem in seq validConfigs, invalidSubset in seq restrictedInvalidSubsets 
  																											--& not Utilities`mapToSet(invalidSubset) subset Utilities`mapToSet(elem)};
  							dcl newValidConfigs : seq of config := [];
  							for invalidSubset in restrictedInvalidSubsets do (
  								newValidConfigs := newValidConfigs ^ [elem | elem in seq validConfigs & not Utilities`mapToSet(invalidSubset) subset Utilities`mapToSet(elem)];
  								);
  							if newValidConfigs <> [] then validConfigs := newValidConfigs;
  					);
  	public printConfigs: () ==> ()
  					printConfigs() == for validConfig in validConfigs do IO`println(validConfig);
  					
  	public searchFeatureTree: (Feature | Parent) * bool ==> ()
  					searchFeatureTree(feature, hasOrParent) == 
  					(
  							if not hasOrParent then notOrParentConfigs(feature);
  							if isofclass(Parent, feature) then
  								if feature.isXorParent() then setXorParentConfigs(feature)
  								else if feature.isOrParent() then setOrParentConfigs(feature)
  								else
  								(
  									for subFeature in feature.getSubFeatures() do
  										searchFeatureTree(subFeature, false);
  								)
  					);
  		public notOrParentConfigs: Feature | Parent ==> ()
  						notOrParentConfigs(feature) ==
  						(
  							dcl possibilities : seq of config := [];
  							if feature.isMandatory() then possibilities := [{feature.getName() |-> true}]
  							else possibilities := [{feature.getName() |-> true},  {feature.getName() |-> false}];
  							if (len validConfigs = 0) then (validConfigs := possibilities)
  							else ( 
  							dcl newValidConfigs : seq of config := [];
  							for validConfig in validConfigs do 
  								for possibility in possibilities do
  										newValidConfigs := newValidConfigs ^ [validConfig munion possibility];
  							validConfigs := newValidConfigs;
  							);
  						);
  		public setXorParentConfigs: Parent ==> ()
  						setXorParentConfigs(parent) ==
  						(
  							dcl subFeaturesLength : int := parent.subFeaturesLen();
  							dcl subFeatures : seq of Feature := parent.getSubFeatures();
  							dcl newValidConfigs : seq of config := [];
  							for validConfig in validConfigs do
  									for	i = 1 to subFeaturesLength do 
  									(
  										dcl elements : config := {|->};
  												for j = 1 to subFeaturesLength do 
		  										(
				  										dcl subFeature : Feature := subFeatures(j);
				  										dcl element : config := {subFeature.getName() |-> false };
				  										if (i = j) then element := {subFeature.getName() |-> true };
				  										elements := elements munion element;
		  										);
		  								newValidConfigs := newValidConfigs ^ [validConfig munion elements];
						  				validConfigs := newValidConfigs;
						  				searchFeatureTree(subFeatures(i), true);
		  								);
		  				);
		  public setOrParentConfigs: Parent ==> ()
  						setOrParentConfigs(parent) ==
  						(
  							dcl subFeatures : set of string := parent.getSubFeaturesNames();
  							dcl possibilities : seq of set of config := [];
  							dcl validPossibilities : seq of config := [];
  							for all subFeature in set subFeatures do
  							 		possibilities := possibilities ^ [{{subFeature |-> b2} | b2 in set {true, false}}];
  							for element in consumeXorPossibilities(possibilities, len possibilities) do
  									for validConfig in validConfigs do
  											validPossibilities := validPossibilities ^ [validConfig munion element];
  							validConfigs := validPossibilities;
  						);
  		public consumeXorPossibilities: seq of set of config * int ==> seq of config
  						consumeXorPossibilities(possibilities, originalLength) ==
  						(
  								dcl validPossibilities : seq of config := [];
  								if len possibilities = 1 then 
  										for all possibility in set possibilities(1) do (
  												validPossibilities := validPossibilities ^ [possibility];
  										)
  								else if len possibilities > 1 then 
		  								for all possibility in set possibilities(1) do (
				  								for element in consumeXorPossibilities(tl possibilities, originalLength) do (
				  										dcl conf : config := possibility munion element;
				  										if not (len possibilities = originalLength and rng conf = {false}) then
				  												validPossibilities := validPossibilities ^ [possibility munion element];
				  								);
		  								);
		  							
  								return validPossibilities;
  								
  						);
traces
-- TODO Define Combinatorial Test Traces here
end ConfigSearcher