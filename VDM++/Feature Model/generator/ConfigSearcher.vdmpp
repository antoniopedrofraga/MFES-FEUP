class ConfigSearcher
types
		public string = Utilities`string;
		public config = Utilities`config;
instance variables
		private root : Parent;
		private nodeCount : int;
		private restrictedInvalidSubsets : seq of config;
		private validConfigs : seq of config := [];
operations
  	public ConfigSearcher: Feature ==> ConfigSearcher
  						ConfigSearcher(r) == (root := r; nodeCount := root.nodeCount(); restrictedInvalidSubsets := root.invalidSubsets(); return self;);
  	public searchConfigs: () ==> () 
  					searchConfigs() == (
  						searchFeatureTree(root, true, []);
  						applyRestrictions();
  					);
  	public applyRestrictions: () ==> ()
  					applyRestrictions() ==
  					(
  							dcl newValidConfigs : set of config := {};
  							for i = 1 to len restrictedInvalidSubsets do (
  									if i = 1 then newValidConfigs := { elem | elem in seq validConfigs & not Utilities`mapToSet(restrictedInvalidSubsets(i)) subset Utilities`mapToSet(elem) }
  									else newValidConfigs := newValidConfigs inter { elem | elem in seq validConfigs & not Utilities`mapToSet(restrictedInvalidSubsets(i)) subset Utilities`mapToSet(elem) }
  							);
  							if newValidConfigs <> {} then validConfigs := setToSeq(newValidConfigs);
  					);
  	public setToSeq: set of config ==> seq of config
							setToSeq(s) == (
													dcl sequence : seq of config := [];
													for all e in set s do sequence := sequence ^ [e];
													return sequence;
													);
  	public printConfigs: () ==> ()
  					printConfigs() == for validConfig in validConfigs do IO`println(validConfig);
  					
  	public searchFeatureTree: (Feature | Parent) * bool * seq of string ==> ()
  					searchFeatureTree(feature, hasDefaultParent, optionalParents) == 
  					(
  							if hasDefaultParent then defaultParentConfigs(feature);
  							checkOptionalParents(feature, optionalParents);
  							if isofclass(Parent, feature) then (
  								dcl newOptionalParents : seq of string := optionalParents;
  								if feature.isXorParent() then xorParentConfigs(feature)
  								else if feature.isOrParent() then orParentConfigs(feature);
  								if not feature.isMandatory() then newOptionalParents := newOptionalParents ^ [feature.getName()];
  								for subFeature in feature.getSubFeatures() do
  									searchFeatureTree(subFeature, feature.isDefaultParent(), newOptionalParents);
  							);
  					);
  		public defaultParentConfigs: (Feature | Parent) ==> ()
  						defaultParentConfigs(feature) ==
  						(
  							dcl possibilities : seq of config := [];
  							if feature.isMandatory() then possibilities := [{feature.getName() |-> true}]
  							else possibilities := [{feature.getName() |-> true},  {feature.getName() |-> false}];
  							if (len validConfigs = 0) then (validConfigs := possibilities)
  							else ( 
  							dcl newValidConfigs : seq of config := [];
  							for validConfig in validConfigs do 
  								for possibility in possibilities do
  										newValidConfigs := newValidConfigs ^ [validConfig munion possibility];
  							validConfigs := newValidConfigs;		
  							);
  						);
  		public xorParentConfigs: Parent ==> ()
  						xorParentConfigs(parent) ==
  						(
  							dcl subFeaturesLength : int := parent.subFeaturesLen();
  							dcl subFeatures : seq of Feature := parent.getSubFeatures();
  							dcl newValidConfigs : seq of config := [];
  							for validConfig in validConfigs do (
  									for	i = 1 to subFeaturesLength do 
  									(
  										dcl elements : config := {|->};
  												for j = 1 to subFeaturesLength do 
		  										(
				  										dcl subFeature : Feature := subFeatures(j);
				  										dcl element : config := {subFeature.getName() |-> false };
				  										if (i = j) then element := {subFeature.getName() |-> true };
				  										elements := elements munion element;
		  										);
		  								newValidConfigs := newValidConfigs ^ [validConfig munion elements];
		  								);
		  								if not parent.isMandatory() and 
		  								Utilities`mapToSet({parent.getName() |-> false}) subset Utilities`mapToSet(validConfig) then
					  					 (
					  					 dcl elements : config := {|->};
					  					 for subFeature in subFeatures do
					  								elements := elements munion {subFeature.getName() |-> false};
					  					 newValidConfigs := newValidConfigs ^ [validConfig munion elements];
					  					 );
		  					);
		  					validConfigs := newValidConfigs;
		  				);
		  public orParentConfigs: Parent ==> ()
  						orParentConfigs(parent) ==
  						(
  							dcl subFeatures : set of string := parent.getSubFeaturesNames();
  							dcl possibilities : seq of set of config := [];
  							dcl validPossibilities : seq of config := [];
  							for all subFeature in set subFeatures do 
  							 		possibilities := possibilities ^ [{{subFeature |-> b2} | b2 in set {true, false}}];
  							for element in consumeOrPossibilities(parent, possibilities, len possibilities) do
  									for validConfig in validConfigs do
  											validPossibilities := validPossibilities ^ [validConfig munion element];
  							validConfigs := validPossibilities;
  						);
  		public consumeOrPossibilities: Feature * seq of set of config * int ==> seq of config
  						consumeOrPossibilities(parent, possibilities, originalLength) ==
  						(
  								dcl validPossibilities : seq of config := [];
  								if len possibilities = 1 then 
  										for all possibility in set possibilities(1) do (
  												validPossibilities := validPossibilities ^ [possibility];
  										)
  								else if len possibilities > 1 then 
		  								for all possibility in set possibilities(1) do (
				  								for element in consumeOrPossibilities(parent, tl possibilities, originalLength) do (
				  										dcl conf : config := possibility munion element;
				  										if not (len possibilities = originalLength and rng conf = {false} and parent.isMandatory()) then
				  												validPossibilities := validPossibilities ^ [possibility munion element];
				  								);
		  								);
		  							
  								return validPossibilities;				
  						);
  		public checkOptionalParents: Feature * seq of string ==> ()
  						checkOptionalParents(feature, optionalParents) == 
  						(	
  								dcl newValidConfigs : set of config := {};
  								for i = 1 to len optionalParents do (
  									dcl invalidConfig : config := {optionalParents(i) |-> false, feature.getName() |-> true};
  									if i = 1 then newValidConfigs := { elem | elem in seq validConfigs & not Utilities`mapToSet(invalidConfig) subset Utilities`mapToSet(elem) }
  									else newValidConfigs := newValidConfigs inter { elem | elem in seq validConfigs & not Utilities`mapToSet(invalidConfig) subset Utilities`mapToSet(elem) }
  								);
  							if newValidConfigs <> {} then validConfigs := setToSeq(newValidConfigs);
  												
  						);
end ConfigSearcher